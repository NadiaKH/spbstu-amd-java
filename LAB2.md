# LAB2

Требуется реализовать обобщенный конвейер обработки данных, на основе которого дальше будет построен многопоточный архиватор. Например, существующие архиваторы - это подобранная последовательность алгоритмов сжатия, чтобы в итоге данные занимали наименьший объем. Наш конвейер поможет нам последовательно применять алгоритмы сжатия к данным, а потом и распараллеливать вычисления.

Архитектура приложения спроектирована за вас, осталось реализовать. Вам предлагается каркас из набора интерфейсов, последовательно имплементировав которые, вы получите готовую лабу (ну или почти). В описании каждой лабораторной будет перечень интерфейсов для ее реализации, на остальное смотреть не нужно до следующих лабораторных.

Все интерфейсы, кроме `MutableWorker` (дальше станет понятно, почему), можно расширять как вам удобно (только на самом деле это не нужно), например:
```
public interface MyReader extends ru.spbstu.amd.javaed.pipeline.io.Reader {
}
```

Также важно помимо общих описаний лабораторных читать документацию в 
[коде](https://github.com/winter-yuki/spbstu-amd-java/tree/master/src/main/java/ru/spbstu/amd/javaed/pipeline),
чтобы точно понимать, какие ответственности делегируются сущностям, выделенным а архитектуре.

Чтобы поспльзоваться интерфейсами, скачайте `jar` последней версии 
[тут](https://drive.google.com/open?id=1nHOb1A9QFvt11BKg4bfI7ZFgErokAsG4) 
и 
[подключите](https://stackoverflow.com/questions/1051640/correct-way-to-add-external-jars-lib-jar-to-an-intellij-idea-project) 
его к проекту в идее.

### Интерфейсы

В этой лабораторной требуется реализовать:
- [MutableWorker](https://github.com/winter-yuki/spbstu-amd-java/blob/master/src/main/java/ru/spbstu/amd/javaed/pipeline/worker/MutableWorker.java)
- [Writer](https://github.com/winter-yuki/spbstu-amd-java/blob/master/src/main/java/ru/spbstu/amd/javaed/pipeline/io/Writer.java)
- [StandalonePipeline](https://github.com/winter-yuki/spbstu-amd-java/blob/master/src/main/java/ru/spbstu/amd/javaed/pipeline/StandalonePipeline.java)

Также обратите внимание на содержимое пакета `ru.spbstu.amd.javaed.pipeline.worker`. Например, там объявлены полезные исключения.

Далее уточним, что за сущности моделируют эти интерфейсы.

### Workers

Чтобы разные алгоритмы кодирования работали вместе, нам нужно ввести для них некоторое обобщение. В нашем случае - это абстракций "Рабочий", `Worker` (далее, кратко `W`).

Рабочие - единицы конвейера обработки информации. Конвейер получается последовательным присоединением следующих рабочих к предыдущим (метод `setNext` у `MutableWorker`). 

Итого, последовательность рабочих - односвязный список. Во время работы конвейера каждый `W` отдает результат своей работы следующему рабочему в цепочке.

Таким образом, имеем две стадии - сборка конвейера (знакомство рабочих) и его работа.

#### Знакомство

Разные алгоритмы могут работать с разными типами данных, пусть их рабочие договариваются о типе на этапе знакомства.

Таким образом, у нас есть `W1` и `W2`. Мы хотим получить конвейер. Присоединяем второй к первому:
```
W1.setNext(W2);
```

В `setNext(next)`:
- Получаем типы, которые `W2` может обработать через метод ```next.getPossibleInputTypes()``` у
  [Worker](https://github.com/winter-yuki/spbstu-amd-java/blob/master/src/main/java/ru/spbstu/amd/javaed/pipeline/worker/Worker.java).
- Выбираем из множества тот тип, который `W1` может производить, запоминаем его.

Если `W1` не умеет конвертировать данные в один из тех типов, которые `W2` может обрабатывать, из `setNext` вылетит исключение `NoCommonTypesException`, как написано в [документации](https://github.com/winter-yuki/spbstu-amd-java/blob/master/src/main/java/ru/spbstu/amd/javaed/pipeline/worker/MutableWorker.java) этого метода.

Заметьте, что из публичных методов рабочих могут вылетать только исключения, унаследованные от 
[WorkerException](https://github.com/winter-yuki/spbstu-amd-java/blob/master/src/main/java/ru/spbstu/amd/javaed/pipeline/worker/WorkerException.java),
это сделано для того, чтобы если человек, который пользуется вашим рабочим, захотел однообразно обрабатывать все ошибки, с ним связанные, он мог это сделать, поймав исключение типа ```WorkerException```.

Какие конкретно исключения могут вылетать из публичных методов рабочих, смотрите в комменариях к коду.

```getPossibleInputTypes()``` возвращает ```Set<Class<?>>```, этого не нужно пугаться. ```Class<?>``` содержит в себе информацию о каком-то конкретном типе. "Вопросик" тут означает, что нам не важно, какой конкретно тип там лежит, нам важно, что мы можем сравнивать через ```==``` объекты типа ```Class<?>```. Например:
```
Class<?> cls = String.class;
assert cls != byte[].class; // Это правда
assert cls == String.class; // Это тоже правда
```

##### Типы

- поддерживаем
    - byte[]
    - char[]
    - String
    
Принимать рабочий может один из этих типов, но на выходе должен уметь конвертировать данные во все.

Чтобы не было проблем с конвертацией байт в символы и наоборот, введем ограничения:
- Входной файл должен быть в кодировке UTF-16BE
  (можно в idea выбрать справа снизу и переконвертировать)
- Тогда конвертация в коде ваглядит так:
    - ```new String(chars).getBytes("UTF-16BE")``` (char\[\] -> byte\[\])
    - ```new String(bytes, "UTF-16BE").toCharArray()``` (byte\[\] -> char\[\])
    - к тому же можно полагаться, что размер ```byte[]``` в этой кодировке будет вдвое длиннее соответствующего ```char[]```

#### Работа

Находимся в `worker.work()`.

На параметр `Object producer` не обращаем внимание до 4й лабы.

1. `Worker` получает данные `data` типа `Object` в метод `work`, далее ему нужно определить, какой тип из допустимых к нему пришел с помощью оператора `instanceof`.
2. Далее он обрабатывает пришедшие данные.
3. Конвертирует результат в нужный тип, чтобы отдать следующему.
4. Отдает данные дальше по конвееру ```next.work(result, this);```.
5. В простом варианте будем считать, что возвращается всегда размер коллекции `data` (т.е. ```((byte[]) data).length```, например, если пришли данные в формате `byte[]`).


### StandalonePipeline

Таким образом, у нас есть рабочие, которые договариваются о типе и строятся в цепочку, по которой протекают данные во время работы.

Теперь нам нужна сущность, которая будет их выстраивать в правильном порядке и выдавать затем данные, которые будут протекать по конвейеру, это будет [StandalonePipeline](https://github.com/winter-yuki/spbstu-amd-java/blob/master/src/main/java/ru/spbstu/amd/javaed/pipeline/StandalonePipeline.java).

#### Построение конвейера

Теперь нам нужно усложнить конфигурационный файл программы. В нем как минимум должна быть информация:
- О линейном порядке рабочих.
- О путях к конфигам каждого из рабочих.
- О размере порций данных, которые будут за раз протекать по конвейеру.
- Об именах входного и выходного файлов.

Рабочие представлены в конфиге строковыми именами их классов. Рантайм джавы позволяет создавать экземпляры классов по их имени.

Для создания экземпляра класса, который реализует `MutableWorker` можно воспользоваться его статическим методом `of`, который для вас уже реализован. Чтобы так можно было создать экземпляр вашего рабочего, его класс должен быть публичным и иметь статический метод вида (фабрику):
```
public static MyMutableWorker of(String confPath) {
    return new MyWorker(confPath);
}
```

Тогда создание будет выглядеть:
```
MyMutableWorker mmw = ru.spbstu.amd.javaed.pipeline.worker.MutableWorker.of(
    "my.package.full.name.MyMutableWorker", "path/to/congig"
);
```

Можно было бы создавать рабочих и через конструктор, но код, в котором объекты создаются не напрямую, а через фабрики, поправу считается значительно более гибким.

Заметим, что у последнего рабочего все еще нет следующего, это приведет к ошибке. В конец конвейера добавим еще рабочего, который будет писать данные в файл. Пусть этот рабочий имплементирует интерфейс `Writer`.

```
StandalonePipeline -> Worker1 -> Worker2 -> ... -> WorkerN -> MyWorkerThatWritesToFile
```

Таким образом, мы прочитали конфиг, создали рабочих, которые там указаны, выстроили у нужном порядке на конвейер.
Также, не забыли сохранить ссылку на первого рабочего последовательности.

#### Запуск!

Заметим, что `StandalonePipeline` расширяет стандартный интерфейс `Runnable`, таким образом, он имеет метод `run()`. Сосредоточим логику запуска конвейера в нем.

Таким образом, после вызова `run()` нам нужно в цикле читать данные порциями, размер которых указан в конфиге, и отдавать первому рабочему на ковейере. А уже тот обработает их и передаст дальше.


### Обобщим

Весь конвейер - односвязный список с головой `StandalonePipeline` и элементами `Worker`.
```
StandalonePipeline -> Worker1 -> Worker2 -> ... -> WorkerN -> MyWorkerThatWritesToFile
```

Также `StandalonePipeline` обрабатывает конфиг и выстраивает рабочих в правильном порядке. Когда у него дергают `run()`, он в цикле читает данные из файла и отдает первому рабочему.


### Замечания

Для сдачи лабораторной необходимо, чтобы вы в свой конвейер могли встроить двух разных рабочих от двоих своих товарищей. Документация (комментарии в коде к `MutableWorker` + описания лаб) задает контракт, который нужно соблюдать, чтобы получить гарантии автора интерфейса, что ваши рабочие будут совместимы.

Заметьте, что методы `work` всех рабочих на конвейере вызываются последовательно. Таким образом, если исключение возникнет в одном из них, то оно может долететь до `run()` у `StandalonePipeline`, что очень удобно.

Вы должны определить `границу`, место в коде, в котором будет ```try-catch```, где вы будете ошибки обрабатывать. Целесообразно до метода `run()` в `StandalonePipeline` этого точно не делать.

Не забывайте читать комментарии в исходниках!

Теперь вы можете очень просто тестировать свой алгоритм. Нужно последовательно на конвейер поставить кодировщик, потом декодировщик, и проверить, что файл на выходе ровной такой же, как и на входе.
