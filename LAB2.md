# LAB2

Требуется реализовать обобщенный конвейер обработки данных.

Вам предлагается каркас из набора интерфейсов, последовательно имплементировав которые, вы получите готовую лабу (ну или почти).

Чтобы поспльзоваться ими, скачайте `jar` последней версии 
[тут](https://drive.google.com/open?id=1Ji-11XI_uVZOnhBJuBKU20117a6cDZ_n) 
и [подключите](https://stackoverflow.com/questions/1051640/correct-way-to-add-external-jars-lib-jar-to-an-intellij-idea-project) 
его к проекту в идее.

Особенно тщательно и в соответствии с документацией реализуйте интерфейс 
[MutableWorker](https://github.com/winter-yuki/spbstu-amd-java/blob/master/src/main/java/ru/spbstu/amd/javaed/pipeline/worker/MutableWorker.java).
Для сдачи лабораторной необходимо, чтобы вы в свой конвейер могли встроить двух разных рабочих от двоих своих товарищей.
Документация (комментарии в [коде](https://github.com/winter-yuki/spbstu-amd-java/tree/master/src/main/java/ru/spbstu/amd/javaed/pipeline) и тут) задает контракт, который нужно соблюдать, чтобы получить гарантии автора интерфейса, что ваши рабочие будут совместимы.

Реализуйте интерфейсы
[MutableWorker](https://github.com/winter-yuki/spbstu-amd-java/blob/master/src/main/java/ru/spbstu/amd/javaed/pipeline/worker/MutableWorker.java)
и
[StandalonePipeline](https://github.com/winter-yuki/spbstu-amd-java/blob/master/src/main/java/ru/spbstu/amd/javaed/pipeline/StandalonePipeline.java). 
Получится конвейер, на который можно выставлять разные алгоритмы кодирования (одетые в рабочих).


### Workers

Чтобы разные алгоритмы кодирования работали вместе, нам нужно ввести для них некоторое обобщение. В нашем случае - это абстракций "Рабочий", "Worker" (далее, кратко `W`).

Рабочие - единицы конвейера обработки информации. Конвейер получается последовательным присоединением следующих рабочих к предыдущим (метод `setNext` у `MutableWorker`).

Таким образом, имеем две стадии - сборка конвейера (знакомство рабочих) и его работа.

#### Знакомство

Разные алгоритмы могут работать с разными типами данных, пусть их рабочие договариваются о типе на этапе знакомства.

Таким образом, у нас есть `W1` и `W2`. Мы хотим получить конвейер. Присоединяем второй к первому:
```
W1.setNext(W2);
```

В `setNext(next)`:
- Получаем типы, которые `W2` может обработать через метод ```next.possibleInputTypes()``` у 
  [Worker](https://github.com/winter-yuki/spbstu-amd-java/blob/master/src/main/java/ru/spbstu/amd/javaed/pipeline/worker/Worker.java).
- Выбираем из множества тот тип, который `W1` может производить, запоминаем его. Далее, когда будем у `next` вызывать `work`, будем передавать данные сконвертированные в правильный тип.

Если `W1` не умеет конвертировать данные в один из тех типов, которые `W2` может обрабатывать, из `setNext` вылетит исключение `NoCommonTypesException`, как написано в [документации](https://github.com/winter-yuki/spbstu-amd-java/blob/master/src/main/java/ru/spbstu/amd/javaed/pipeline/worker/MutableWorker.java) этого метода.

Заметьте, что из публичных методов рабочих могут вылетать только исключения, унаследованные от 
[WorkerException](https://github.com/winter-yuki/spbstu-amd-java/blob/master/src/main/java/ru/spbstu/amd/javaed/pipeline/worker/WorkerException.java),
это сделано для того, чтобы если человек, который пользуется вашим рабочим, захотел однообразно обрабатывать все ошибки, с ним связанные, он мог это сделать, поймав исключение типа ```WorkerException```.

Какие конкретно исключения могут вылетать из публичных методов рабочих, смотрите в комменариях к коду.

##### Типы

- поддерживаем
    - byte[]
    - char[]
    - String
    
Принимать рабочий может один из этих типов, но на выходе должен уметь конвертировать данные во все.

Чтобы не было проблем с конвертацией байт в символы и наоборот, введем ограничения:
- Входной файл должен быть в кодировке UTF-16BE
  (можно в idea выбрать справа снизу и переконвертировать)
- Тогда конвертация в коде ваглядит так:
    - ```new String(chars).getBytes("UTF-16BE")``` (char\[\] -> byte\[\])
    - ```new String(bytes, "UTF-16BE").toCharArray()``` (byte\[\] -> char\[\])
    - к тому же можно полагаться что размер ```byte[]``` в этой кодировке
    будет вдвое длиннее соттветствующего ```char[]```

#### Работа

1. `Worker` получает данные типа `Object` в метод `work`, далее ему нужно определить, какой тип из допустимых к нему пришел с помощью оператора `instanceof`.
2. Далее он обрабатывает пришедшие данные.
3. Конвертирует результат в нужный тип, чтобы отдать следующему.
4. Отдает данные дальше по конвееру ```next.work(result, this);```.


### StandalonePipeline

Таким образом, у нас есть рабочие, которые договариваются о типе и строятся в цепочку, по которой протекают данные.

Теперь нам нужна сущность, которая будет их выстраивать в правильном порядке и выдавать затем данные, которые будут протекать по конвейеру,
это будет [StandalonePipeline](https://github.com/winter-yuki/spbstu-amd-java/blob/master/src/main/java/ru/spbstu/amd/javaed/pipeline/StandalonePipeline.java).

#### Построение конвейера

Теперь нам нужно усложнить конфигурационный файл программы. В нем как минимум должна быть информация:
- О линейном порядке рабочих.
- О путях к конфигам каждого из рабочих.
- О размере порций данных, которые будут за раз протекать по конвейеру.
- Об именах входного и выходного файлов.

Рабочие представлены в конфиге строковыми именами их классов. Рантайм джавы позволяет создавать экземпляры классов по их имени.

Для создания экземпляра класса, который реализует `MutableWorker` можно воспользоваться его статическим методом `of`, который для вас уже реализован. Чтобы так можно было создать экземпляр вашего рабочего, его класс должен быть публичным и иметь статический метод вида (фабрику):
```
public static MyMutableWorker of(String confPath) {
    return new MyWorker(confPath);
}
```

Тогда создание будет выглядеть:
```
MyMutableWorker mmw = ru.spbstu.amd.javaed.pipeline.worker.MutableWorker.of(
    "my.package.full.name.MyMutableWorker", "path/to/congig"
);
```

Можно было бы создавать рабочих и через конструктор, но код, в котором объекты создаются не напрямую, а через фабрики, поправу считается значительно более гибким.

Заметим, что у последнего рабочего все еще нет следующего, это приведет к ошибке. В конец конвейера добавим еще рабочего, который будет писать данные в файл.

```
StandalonePipeline -> Worker1 -> Worker2 -> ... -> WorkerN -> MyWorkerThatWritesToFile
```

Таким образом, мы прочитали конфиг, создали рабочих, которые там указаны, выстроили у нужном порядке на конвейер.
Также, не забыли сохранить ссылку на первого рабочего последовательности.

#### Запуск!

Заметим, что `StandalonePipeline` расширяет стандартный интерфейс `Runnable`, таким образом, он имеет метод `run()`. Сосредоточим логику запуска конвейера в нем.

Таким образом, после вызова `run()` нам нужно в цикле читать данные порциями, размер которых указан в конфиге, и отдавать первому рабочему на ковейере. А уже тот обработает их и передаст дальше.


### Замечания

Заметьте, что методы `work` всех рабочих на конвейере вызываются последовательно. Таким образом, если исключение возникнет в одном из них, то оно может долететь до `run()` у `StandalonePipeline`, что очень удобно.

Вы должны определить `границу`, место в коде, в котором будет ```try-catch```, где вы будете ошибки обрабатывать. Целесообразно до метода `run()` этого точно не делать.
