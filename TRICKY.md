# TRICKY

Неочевидные грабли (и фичи) джавы. Самые-самые основные моменты языка и связанные с ними тонкости.

## Типы
Все типы в Java делятся на примитивные и ссылочные.

### Примитивные типы
Занимаемый примитивами объем памяти:
- byte - 1 байт;
- short - 2 байта;
- int - 4 байта;
- long - 8 байт;
- float - 4 байта;
- double - 8 байт;
- char - 2 байта;
- boolean - не определено.

### Ссылочные типы
Все ссылочные типы являются наследниками класса Object.

## Преобразование типов
Любые два типа (как ссылочных, так и примитивных) могут быть либо конвертируемыми друг в друга, либо неконвертируемыми (inconvertible types). Чтобы привести один тип к другому, используется оператор ```()``` приведения типа. Не всегда обязательно его использовать. Существуют автоматические преобразования типов, и для них (и только для них) мы можем не использовать оператор приведения.

### Преобразование примитивных типов
Для примитивных типов автоматические преобразования представлены на картинке.

![AutomaticTypeConversionJava](https://user-images.githubusercontent.com/41269755/76460514-2c501200-63ef-11ea-8ca2-01c2256e786c.png)

Перечислим следующие интересные особенности.
- Тип float занимает меньший объем памяти, чем long, при этом имеется автоматическое преобразование из long в float, пусть и с потерей точности. То есть нет такого правила, что автоматическое преобразование обязательно происходит из типа с меньшей разрядностью в тип с большей разрядностью.
- Тип byte занимает меньше памяти, чем char, а тип short -- столько же, сколько и char. Но автоматического преобразования byte, short в char нет. Дело в том, что char и byte -- знаковые типы (старший бит является знаковым), а char - беззнаковый тип, поэтому поведение char отлично от поведения byte и short. При этом имеется неявное преобразование char в int, не смотря на знаковость int и беззнаковость char, и все потому, что переменные char и int имеют одинаковое поведение.
- Тип boolean не конвертируется ни в один другой примитивный тип. Все остальные примитивные типы конвертируемы друг в друга (явно или неявно).

Примеры преобразования примитивных типов:
```
int i = 4;
byte b = i; // Ошибка, поскольку отсутствует автоматическое преобразование int в byte (см. картинку).
```
```
char c = 'A';
double d = c; // Не ошибка, поскольку присутствует неявное преобразование char в double (см. картинку).
```
```
char c = 128;
byte b = (byte)c; // Не ошибка, хотя 128 не помещается в тип byte. Спойлер: в b хранится значение -128.
```

Отдельного внимания заслуживает преобразование типов при арифметических операциях, которое подчиняется следующему правилу:
1. если один из операндов имеет тип ```double```, то все операнды приводятся к ```double```;
2. иначе, если один из операндов имеет тип ```float```, то все операнды приводятся к ```float```;
3. иначе, если один из операндов имеет тип ```long```, то все операнды приводятся к ```long```;
4. иначе все операнды приводятся к int.
Приведем примеры для демонстрации этого правила.
```
byte b1 = 17;
byte b2 = 72;
byte res = b1 + b2; /* Нет double, нет float, нет long, поэтому все операнды преобразуются к int.
Ошибка, поскольку результат выражения имеет тип int; необходимо явно преобразовать результат выражения к типу byte. */
```
```
double d = 6.0;
char c = 'G';
int i = 5;
double res = i * d / c + 1.0F; /* Операнд d имеет тип double, поэтому все операнды преобразуются к double.
Ошибки нет. */
```
```
int i = 10000;
double res = i * 1.0F; /* Нет double, есть float, поэтому все преобразуется в float.
Ошибки нет. */
```
Отметим, что в случае, когда в выражении участвуют обертки, правила остаются без изменений.
```
Long L1 = 4L;
Long L2 = 52L;
long res = L1 + L2; /* Нет double (или Double), нет float (или Float), есть Long, поэтому все преобразуется к long. Заметим, что результат выражения будет именно примитивного типа long, а не ссылочного Long;
Ошибки нет. */
```
```
Float F = 5.76F;
char c = 'h';
float f = F + c; /* Нет double (или Double), есть Float, поэтому все преобразуется в float, 
Ошибки нет. */
```

### Преобразование ссылочных типов
TODO

#### Поля и переменные

- field: static final
    - не инит по умолчанию
    - инит через = или в статик конструкторе
- field: static
    - инит по умолчанию
    - инит где угодно + статик конструктор
- field: final
    - не инит по умолчанию
    - инит через = или в конструкторе
- field:
    - инит по умолчанию
    - инит где угодно
- local: final
    - не инит по умолчанию
    - инит только один раз перед использованием
- local:
    - не инит по умолчанию
    - инит перед использованием
    
#### Касты

- Касты чисел
    - Целые в целые которые больше
    - Дробные так же
    - 
      ```
      final int i = -128;
      byte b = i;
      ```
      (без final не сработает, если число в меньший тип не поместится, то тоже не сработает) 
      (с дробными не сработает)
    - остальное - CE
- Автоматический boxing/unboxing
    ```
    double d = new Double(5);
    Int i = 5;
    ```
- Касты ссылочных
    - Upcast:
        ```
        class A {}
        class B extends A {}
        A a = new B();
        ```
    - Ковариантность/контравариантность
        типа так
        ```
        Set<? extends Number> ss = new HashSet<Integer>();
        ```
        + штуки с <? super T>
    - Остальное - CE
- Касты массивов
    - В надтип ссылочного типа
        ```
        Object[][] os = new Integer[0][0];
        ```
        (массив нулевой длины, кстати, сделать можно, а -1й - RE)
    - Массивы примитивных типов никуда не кастятся
    - ```Object o = new int[0][0];``` Массивы - тоже почти честные объекты!

    
#### Статическое и не очень

- Статики - атрибуты типов, если знаем тип, то можем достать нужный статик (если модификаторы доступа позволят)
- Не статики - атрибуты объектов типов. Их можно получить только через экземпляр.

    
#### Файлы, пакеты и все-все-все!

- В файле с именем `AAA` может быть не более одного публичного класса, и если он есть, он должен называться `AAA`.
- Пакеты `ru.penguin.cooking` и `ru.penguin` никак не связаны иерархически. Штуки, видные в пределах пакета
не видны в "подпакетах", ибо таковых не бывает.

#### Модификаторы доступа
- class, который в файле с отступом 0 слева.
    - без модификатора (package private) - виден только в этом же пакете. (В подпакетах не виден, т.к. их не бывает)
    - public - виден всем (помним про имя этого файла тогда)
    - private - не бывает, уходим в котлин.
- class, вложенный в другой
    - public - виден всем
    - private - виден внутри объемлющего класса
    - protected - виден наследникам
- методы - все как и ожидается
- в отличие от плюсов
    ```
    class A{
        protected void foo() {...}
    }
    class B extends A {
        void bar() {
            C = new C();
            c.foo(); // Нельзя дергать протектед штуки из другой иерархии!!!
        }
    class C extends A {}
    ```
- final у класса - от него нельзя наследоваться
- final у метода - его нельзя переопределить в наследнике
- final у static метода - ... это как?

#### Вложенные static и не очень классы
- static - обычные классы, ничего не знают про внешний класс, его имя - просто пространство имен
   ```
    class A { static class AA {} }
    A.AA aa = new A.AA();
    ```
- не static - держат ссылку на внешний класс, имеет доступ ко всем, даже приватным членам внещнего класса
    ```
    class A{
        class AA {
            public getI() { return i; }
        }
        private int i = 64;
    }
    A.AA aa = new A().new AA();
    int outerI = aa.getI();
    ```

#### Ф-ции с переменным числом аргументов
    TODO
    
#### Дженерики
    TODO
