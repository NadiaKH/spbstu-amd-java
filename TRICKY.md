# TRICKY

Неочевидные грабли (и фичи) джавы.

#### Поля и переменные

- field: static final
    - не инит по умолчанию
    - инит через = или в статик конструкторе
- field: static
    - инит по умолчанию
    - инит где угодно + статик конструктор
- field: final
    - не инит по умолчанию
    - инит через = или в конструкторе
- field:
    - инит по умолчанию
    - инит где угодно
- local: final
    - не инит по умолчанию
    - инит только один раз перед использованием
- local:
    - не инит по умолчанию
    - инит перед использованием
    
#### Касты

- Касты чисел
    - Целые в целые которые больше
    - Дробные так же
    - 
      ```
      final int i = -128;
      byte b = i;
      ```
      (без final не сработает, если число в меньший тип не поместится, то тоже не сработает) 
      (с дробными не сработает)
    - остальное - CE
- Автоматический boxing/unboxing
    ```
    double d = new Double(5);
    Int i = 5;
    ```
- Касты ссылочных
    - Upcast:
        ```
        class A {}
        class B extends A {}
        A a = new B();
        ```
    - Ковариантность/контравариантность
        типа так
        ```
        Set<? extends Number> ss = new HashSet<Integer>();
        ```
        + штуки с <? super T>
    - Остальное - CE
- Касты массивов
    - В надтип ссылочного типа
        ```
        Object[][] os = new Integer[0][0];
        ```
        (массив нулевой длины, кстати, сделать можно, а -1й - RE)
    - Массивы примитивных типов никуда не кастятся
    - ```Object o = new int[0][0];``` Массивы - тоже почти честные объекты!

    
#### Статическое и не очень

- Статики - атрибуты типов, если знаем тип, то можем достать нужный статик (если модификаторы доступа позволят)
- Не статики - атрибуты объектов типов. Их можно получить только через экземпляр.

    
#### Файлы, пакеты и все-все-все!

- В файле с именем `AAA` может быть не более одного публичного класса, и если он есть, он должен называться `AAA`.
- Пакеты `ru.penguin.cooking` и `ru.penguin` никак не связаны иерархически. Штуки, видные в пределах пакета
не видны в "подпакетах", ибо таковых не бывает.

#### Модификаторы доступа
- class, который в файле с отступом 0 слева.
    - без модификатора (package private) - виден только в этом же пакете. (В подпакетах не виден, т.к. их не бывает)
    - public - виден всем (помним про имя этого файла тогда)
    - private - не бывает, уходим в котлин.
- class, вложенный в другой
    - public - виден всем
    - private - виден внутри объемлющего класса
    - protected - виден наследникам
- методы - все как и ожидается
- в отличие от плюсов
    ```
    class A{
        protected void foo() {...}
    }
    class B extends A {
        void bar() {
            C = new C();
            c.foo(); // Нельзя дергать протектед штуки из другой иерархии!!!
        }
    class C extends A {}
    ```
- final у класса - от него нельзя наследоваться
- final у метода - его нельзя переопределить в наследнике
- final у static метода - ... это как?

#### Вложенные static и не очень классы
- static - обычные классы, ничего не знают про внешний класс, его имя - просто пространство имен
   ```
    class A { static class AA {} }
    A.AA aa = new A.AA();
    ```
- не static - держат ссылку на внешний класс, имеет доступ ко всем, даже приватным членам внещнего класса
    ```
    class A{
        class AA {
            public getI() { return i; }
        }
        private int i = 64;
    }
    A.AA aa = new A().new AA();
    int outerI = aa.getI();
    ```

#### Ф-ции с переменным числом аргументов
    TODO
    
#### Дженерики
    TODO