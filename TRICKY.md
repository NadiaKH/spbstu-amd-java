# TRICKY

Неочевидные грабли (и фичи) джавы.

#### Примитивные типы

Занимаемый примитивами объем памяти:
- byte - 1 байт;
- short - 2 байта;
- int - 4 байта;
- long - 8 байт;
- float - 4 байта;
- double - 8 байт;
- char - 2 байта;
- boolean - не определено.

#### Преобразования примитивных типов
Преобразование между двумя типами может быть либо допустимым, либо недопустимым, когда два типа не конвертируются друг в друга (inconvertible types). Если два типа конвертируемы друг в друга, то преобразование должно быть выполнено явно с помощью оператора () приведения типа. Однако существуют автоматические преобразования (см. картинку), и для них (и только для них) мы можем не использовать оператор приведения.

![Automatic type conversion](https://postimg.cc/5XcFc8Gj)

Заметим также следующее.
- Тип float занимает меньший объем памяти, чем long, при этом имеется автоматическое преобразование из long в float, пусть и с потерей точности. 
- byte занимает меньше памяти, чем char, а тип short -- столько же, но автоматического преобразования byte, short в char нет. Дело не в объеме занимаемой памяти, а в том, что char и byte - знаковые типы (то есть, старший бит является знаковым), а char - беззнаковый тип, и потому поведение char отлично от поведения byte и short. При этом присутствует неявное преобразование char в int, не смотря на знаковость int и беззнаковость char, и все потому, что переменные int и char имеют одинаковое поведение.
- Тип boolean не конвертируется ни в один другой примитивный тип. Все остальные примитивные типы можно конвертировать друг в друга (явно или неявно).

Примеры на преобразование примитивных типов:
```
int i = 4;
byte b = i; // ошибка, поскольку отсутствует автоматическое преобразование int в byte (см. картинку)
```
```
char c = 'A';
double d = c; // не ошибка, поскольку присутствует неявное преобразование char в double (см. картинку)
```
```
char c = 128;
byte b = (char)c; // не ошибка, хотя 128 не помещается в 1 байт. Спойлер: в b хранится значение -128
```

#### Поля и переменные

- field: static final
    - не инит по умолчанию
    - инит через = или в статик конструкторе
- field: static
    - инит по умолчанию
    - инит где угодно + статик конструктор
- field: final
    - не инит по умолчанию
    - инит через = или в конструкторе
- field:
    - инит по умолчанию
    - инит где угодно
- local: final
    - не инит по умолчанию
    - инит только один раз перед использованием
- local:
    - не инит по умолчанию
    - инит перед использованием
    
#### Касты

- Касты чисел
    - Целые в целые которые больше
    - Дробные так же
    - 
      ```
      final int i = -128;
      byte b = i;
      ```
      (без final не сработает, если число в меньший тип не поместится, то тоже не сработает) 
      (с дробными не сработает)
    - остальное - CE
- Автоматический boxing/unboxing
    ```
    double d = new Double(5);
    Int i = 5;
    ```
- Касты ссылочных
    - Upcast:
        ```
        class A {}
        class B extends A {}
        A a = new B();
        ```
    - Ковариантность/контравариантность
        типа так
        ```
        Set<? extends Number> ss = new HashSet<Integer>();
        ```
        + штуки с <? super T>
    - Остальное - CE
- Касты массивов
    - В надтип ссылочного типа
        ```
        Object[][] os = new Integer[0][0];
        ```
        (массив нулевой длины, кстати, сделать можно, а -1й - RE)
    - Массивы примитивных типов никуда не кастятся
    - ```Object o = new int[0][0];``` Массивы - тоже почти честные объекты!

    
#### Статическое и не очень

- Статики - атрибуты типов, если знаем тип, то можем достать нужный статик (если модификаторы доступа позволят)
- Не статики - атрибуты объектов типов. Их можно получить только через экземпляр.

    
#### Файлы, пакеты и все-все-все!

- В файле с именем `AAA` может быть не более одного публичного класса, и если он есть, он должен называться `AAA`.
- Пакеты `ru.penguin.cooking` и `ru.penguin` никак не связаны иерархически. Штуки, видные в пределах пакета
не видны в "подпакетах", ибо таковых не бывает.

#### Модификаторы доступа
- class, который в файле с отступом 0 слева.
    - без модификатора (package private) - виден только в этом же пакете. (В подпакетах не виден, т.к. их не бывает)
    - public - виден всем (помним про имя этого файла тогда)
    - private - не бывает, уходим в котлин.
- class, вложенный в другой
    - public - виден всем
    - private - виден внутри объемлющего класса
    - protected - виден наследникам
- методы - все как и ожидается
- в отличие от плюсов
    ```
    class A{
        protected void foo() {...}
    }
    class B extends A {
        void bar() {
            C = new C();
            c.foo(); // Нельзя дергать протектед штуки из другой иерархии!!!
        }
    class C extends A {}
    ```
- final у класса - от него нельзя наследоваться
- final у метода - его нельзя переопределить в наследнике
- final у static метода - ... это как?

#### Вложенные static и не очень классы
- static - обычные классы, ничего не знают про внешний класс, его имя - просто пространство имен
   ```
    class A { static class AA {} }
    A.AA aa = new A.AA();
    ```
- не static - держат ссылку на внешний класс, имеет доступ ко всем, даже приватным членам внещнего класса
    ```
    class A{
        class AA {
            public getI() { return i; }
        }
        private int i = 64;
    }
    A.AA aa = new A().new AA();
    int outerI = aa.getI();
    ```

#### Ф-ции с переменным числом аргументов
    TODO
    
#### Дженерики
    TODO
